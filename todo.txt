register a reset listener with a contained object so we can reset the container



1. Min-threshold, soft-max, hard-max, and overlaps.
2. Token-to-character conversion (~3.9 per token).
3. Segmentation and encoding on cleaned text while
   tracking raw and cleaned text lengths separately.



max_len = 1024

max = n

if index == 0:
  i_overlap = 0
  f_overlap = 0.1 N

else:
  i_overlap = 0.1 N
  f_overlap = 0.1 N

soft_max = 0.8 N


while True:
  if can add fragment to segment:
    add fragment to segment
    break
  else:
    if segment is empty:
    segment = new segment

article_segments = []
segment = Segment()
article_segments.append(segment)

while section = sections.shift():
    if segment.clean_length + section.clean_length <= max_len:

      # simple case, just add section
      add section to segment
      continue

    if current segment length == 0:
      # if first section is too long, split it
      first, remainder = section.split(max-len)
      segment.append(first)
      sections.unshift(remainder)
      continue

    # add overlap to the end of the current segment
    overlap = min(max_overlap, max_len - current segment length)
    segment.append(section[-overlap:])

    # create a new segment






for a_index, article in articles:
  segment_length = 0
  for p_index, paragraph in article:
    soft_max = 0.9 * N if p_index == 0 else 0.8 * soft_max

    if segment_length + len(paragraph) < hard_max:
      segment.append(paragraph)


    if segment_length + len(paragraph) < soft_max:
      segment_length += len(paragraph)
    elif segment_length + len(paragraph) < hard_max:
      segment_length += len(paragraph)
    elif segment_length == 0:
      segment_length = paragraph[:soft_max]
      segment_length = paragraph[soft_max:]

      segment = new segment(paragraph)
      segment_length = len(paragraph)
      yield segment_length, article, p_index




indexer(Dispatcher):
  def add_paragraph(paragraph)
    self.articles[-1].append_paragraph(paragraph)
    super().handle(paragraph)

validator(Dispatcher):
    def __init__(self, dispatcher):
        self.dispatcher = dispatcher

    def validate(self, paragraph):
      self.validate(paragraph)
      super().handle(paragraph)


def main_simple_in_process():
  indexer = Indexer()
  validator = Validator()
  dumper = Dumper()

  indexer.register_handler(lambda par: validator.validate(par))
  indexer.register_handler(lambda par: dumper.dump(par))


def main_queued_threaded():
  indexer = Indexer()
  validator = Validator()
  dumper = Dumper()

  validator_stage = QueuedStage()
  validator_stage.register_handler(lambda par: validator.validate(par))
  indexer.register_handler(validator_stage)

  dumper_stage = QueuedStage()
  dumper_stage.register_handler(lambda par: dumper.dump(par))
  indexer.register_handler(dumper_stage)

  validator_stage.start()
  dumper_stage.start()

  indexer.index(path)

  validator_stage.stop()
  dumper_stage.stop()



########################################################


IndexBuilder:
    def handle_element(element):
        pass

SnippetValidator:
    def __init__(self, args: argparse.Namespace):
        self.args = args

    def validate_element(element):
        self._validate_element(element)
        self.handle_element(element)

    def handle_element(element):
        pass

IndexDumper:
    def dump_element(element):
        self._dump_element(element)
        self.handle_element(element)

    def dump_element(element):
        pass



def main():
  builder = IndexBuilder()

  if mode == "inline":
      validator = SnippetValidator(args)
      builder.register_handler(lambda element: validator.validate_element(element))

      dumper = IndexDumper(args)
      builder.register_handler(lambda element: dumper.dump_element(element))
  else:
      validator_stage = QueuedStage().delayed_initialize(lambda self: self.)

      validator = QueuedStage()
      validator.register_handler(SnippetValidator())

  dumper = IndexDumper()

  builder.register_handler(validator)
  builder.register_handler(dumper)
